const axios = require('axios');

class AIReply {
    constructor() {
        this.apiKey = process.env.GEMINI_API_KEY;
        this.model = process.env.GEMINI_MODEL || 'gemini-2.0-flash';
        this.apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent`;
        
        this.conversationHistory = new Map(); // Store conversation history
        this.rateLimits = new Map(); // Rate limiting per user
        
        // AI personality and behavior settings
        this.botName = process.env.BOT_NAME || 'WhatsApp Assistant';
        this.personality = process.env.BOT_PERSONALITY || 'friendly_helpful_human_like';
        this.fallbackReply = process.env.FALLBACK_REPLY || 'Sorry yaar, thoda issue ho gaya. Tum bolo kya chahiye?';
        
        // Language detection patterns
        this.languagePatterns = {
            hindi: /[\u0900-\u097F]/,
            english: /^[a-zA-Z\s.,!?'"]*$/,
            hinglish: /(?=.*[a-zA-Z])(?=.*[\u0900-\u097F])|(?=.*[a-zA-Z])(?=.*(?:hai|hain|kya|kaise|kaha|kab|kyun|jo|ki|ka|ke|ko|me|se|pe|par))/i,
            urdu: /[\u0600-\u06FF]/,
            bengali: /[\u0980-\u09FF]/,
            tamil: /[\u0B80-\u0BFF]/,
            gujarati: /[\u0A80-\u0AFF]/,
            marathi: /[\u0900-\u097F]/
        };
        
        this.initializeSystem();
    }
    
    initializeSystem() {
        if (!this.apiKey) {
            console.error('‚ùå GEMINI_API_KEY not found in environment variables');
            throw new Error('Gemini API key is required');
        }
        
        console.log('ü§ñ AI Reply system initialized');
        console.log(`üé≠ Personality: ${this.personality}`);
        console.log(`üåç Multi-language support enabled`);
        
        // Cleanup old conversations every hour
        setInterval(() => {
            this.cleanupOldConversations();
        }, 3600000); // 1 hour
    }
    
    async generateReply(message, fromNumber, context = {}) {
        try {
            console.log(`ü§ñ Generating reply for ${fromNumber}: ${message.substring(0, 50)}...`);
            
            // Rate limiting check
            if (!this.checkRateLimit(fromNumber)) {
                console.log(`‚è±Ô∏è Rate limited: ${fromNumber}`);
                return null;
            }
            
            // Detect message language
            const language = this.detectLanguage(message);
            console.log(`üåç Detected language: ${language}`);
            
            // Get conversation history
            const history = this.getConversationHistory(fromNumber);
            
            // Build prompt
            const prompt = this.buildPrompt(message, language, history, context);
            
            // Generate AI response
            const aiResponse = await this.callGeminiAPI(prompt);
            
            if (aiResponse) {
                // Save to conversation history
                this.updateConversationHistory(fromNumber, message, aiResponse, language);
                
                console.log(`‚úÖ AI reply generated: ${aiResponse.substring(0, 50)}...`);
                return aiResponse;
            }
            
            return this.getFallbackReply(language);
            
        } catch (error) {
            console.error('‚ùå AI reply generation failed:', error);
            return this.getFallbackReply('hinglish');
        }
    }
    
    detectLanguage(text) {
        // Remove URLs, numbers, and special characters for better detection
        const cleanText = text.replace(/https?:\/\/[^\s]+/g, '').replace(/\d+/g, '').trim();
        
        if (this.languagePatterns.hinglish.test(cleanText)) {
            return 'hinglish';
        } else if (this.languagePatterns.hindi.test(cleanText)) {
            return 'hindi';
        } else if (this.languagePatterns.urdu.test(cleanText)) {
            return 'urdu';
        } else if (this.languagePatterns.bengali.test(cleanText)) {
            return 'bengali';
        } else if (this.languagePatterns.tamil.test(cleanText)) {
            return 'tamil';
        } else if (this.languagePatterns.gujarati.test(cleanText)) {
            return 'gujarati';
        } else if (this.languagePatterns.english.test(cleanText)) {
            return 'english';
        }
        
        return 'hinglish'; // Default to hinglish for mixed content
    }
    
    buildPrompt(message, language, history, context) {
        const systemPrompts = {
            hinglish: `You are a friendly WhatsApp assistant named ${this.botName}. Reply in natural Hinglish (Hindi + English mix) like a real Indian friend would. Be conversational, helpful, and use common Hindi words mixed with English. Keep replies short and casual, max 2-3 sentences. Use emojis naturally but don't overdo it.`,
            
            hindi: `‡§Ü‡§™ ${this.botName} ‡§®‡§æ‡§Æ ‡§ï‡•á WhatsApp ‡§Ö‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§π‡•à‡§Ç‡•§ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§ï‡•É‡§§‡§ø‡§ï ‡§î‡§∞ ‡§Æ‡•à‡§§‡•ç‡§∞‡•Ä‡§™‡•Ç‡§∞‡•ç‡§£ ‡§§‡§∞‡•Ä‡§ï‡•á ‡§∏‡•á ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç‡•§ ‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§ ‡§î‡§∞ ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§∞‡§π‡•á‡§Ç‡•§`,
            
            english: `You are ${this.botName}, a WhatsApp assistant. Reply in clear, friendly English. Be conversational and helpful. Keep responses brief and natural.`,
            
            urdu: `ÿ¢Ÿæ ${this.botName} ŸÜÿßŸÖ€å WhatsApp ÿßÿ≥ÿ≥ŸπŸÜŸπ €Å€å⁄∫€î ÿßÿ±ÿØŸà ŸÖ€å⁄∫ ÿØŸàÿ≥ÿ™ÿßŸÜ€Å ÿßŸÜÿØÿßÿ≤ ŸÖ€å⁄∫ ÿ¨Ÿàÿßÿ® ÿØ€å⁄∫€î ŸÖÿÆÿ™ÿµÿ± ÿßŸàÿ± ŸÖÿØÿØ⁄Øÿßÿ± ÿ±€Å€å⁄∫€î`,
            
            bengali: `‡¶Ü‡¶™‡¶®‡¶ø ${this.botName} ‡¶®‡¶æ‡¶Æ‡ßá‡¶∞ WhatsApp ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï‡•§ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º ‡¶¨‡¶®‡ßç‡¶ß‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶≠‡¶æ‡¶¨‡ßá ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶®‡•§ ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï ‡¶•‡¶æ‡¶ï‡ßÅ‡¶®‡•§`,
            
            tamil: `‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ${this.botName} ‡Æé‡Æ©‡Øç‡Æ± WhatsApp ‡Æâ‡Æ§‡Æµ‡Æø‡ÆØ‡Ææ‡Æ≥‡Æ∞‡Øç. ‡Æ§‡ÆÆ‡Æø‡Æ¥‡Æø‡Æ≤‡Øç ‡Æ®‡Æü‡Øç‡Æ™‡Ææ‡Æ© ‡ÆÆ‡ØÅ‡Æ±‡Øà‡ÆØ‡Æø‡Æ≤‡Øç ‡Æ™‡Æ§‡Æø‡Æ≤‡Æ≥‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç. ‡Æö‡ØÅ‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ÆÆ‡Ææ‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æâ‡Æ§‡Æµ‡Æø‡Æï‡Æ∞‡ÆÆ‡Ææ‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç ‡Æá‡Æ∞‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç‡•§`,
            
            gujarati: `‡™§‡™Æ‡´á ${this.botName} ‡™®‡™æ‡™Æ‡™®‡™æ WhatsApp ‡™∏‡™π‡™æ‡™Ø‡™ï ‡™õ‡´ã‡•§ ‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä‡™Æ‡™æ‡™Ç ‡™Æ‡™ø‡™§‡´ç‡™∞‡™§‡™æ‡™™‡´Ç‡™∞‡´ç‡™£ ‡™∞‡´Ä‡™§‡´á ‡™ú‡™µ‡™æ‡™¨ ‡™Ü‡™™‡´ã‡•§ ‡™ü‡´Ç‡™Ç‡™ï‡™æ ‡™Ö‡™®‡´á ‡™Æ‡™¶‡™¶‡™∞‡´Ç‡™™ ‡™∞‡™π‡´ã‡•§`
        };
        
        const systemPrompt = systemPrompts[language] || systemPrompts.hinglish;
        
        let contextualPrompt = systemPrompt;
        
        // Add conversation history context
        if (history.length > 0) {
            contextualPrompt += '\n\nConversation history (last few messages):';
            history.slice(-3).forEach(entry => {
                contextualPrompt += `\nUser: ${entry.userMessage}`;
                contextualPrompt += `\nYou: ${entry.aiReply}`;
            });
        }
        
        // Add special context handling
        contextualPrompt += this.getContextualInstructions(message, language);
        
        contextualPrompt += `\n\nUser's current message: ${message}`;
        contextualPrompt += `\n\nRespond naturally in ${language} as a helpful friend:`;
        
        return contextualPrompt;
    }
    
    getContextualInstructions(message, language) {
        let instructions = '';
        
        // Check for common patterns and add appropriate instructions
        const lowerMessage = message.toLowerCase();
        
        if (lowerMessage.includes('help') || lowerMessage.includes('madad') || lowerMessage.includes('‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø')) {
            instructions += '\nUser is asking for help. Be supportive and offer specific assistance.';
        }
        
        if (lowerMessage.includes('price') || lowerMessage.includes('cost') || lowerMessage.includes('paisa') || lowerMessage.includes('‡¶ü‡¶æ‡¶ï‡¶æ')) {
            instructions += '\nUser is asking about pricing. Be helpful but mention you need more context.';
        }
        
        if (lowerMessage.includes('time') || lowerMessage.includes('samay') || lowerMessage.includes('‡¶∏‡¶Æ‡¶Ø‡¶º')) {
            instructions += '\nUser is asking about time-related information. Be helpful with scheduling.';
        }
        
        if (lowerMessage.includes('thank') || lowerMessage.includes('dhanyawad') || lowerMessage.includes('‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶')) {
            instructions += '\nUser is thanking you. Respond warmly and ask if they need anything else.';
        }
        
        // Emotional support detection
        if (lowerMessage.includes('sad') || lowerMessage.includes('upset') || lowerMessage.includes('problem') || 
            lowerMessage.includes('pareshan') || lowerMessage.includes('‡§¶‡•Å‡§ñ‡•Ä')) {
            instructions += '\nUser seems upset or has problems. Be empathetic and supportive.';
        }
        
        return instructions;
    }
    
    async callGeminiAPI(prompt) {
        try {
            const requestBody = {
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.8,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 200,
                    candidateCount: 1
                },
                safetySettings: [
                    {
                        category: 'HARM_CATEGORY_HARASSMENT',
                        threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                    },
                    {
                        category: 'HARM_CATEGORY_HATE_SPEECH',
                        threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                    },
                    {
                        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
                        threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                    },
                    {
                        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
                        threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                    }
                ]
            };
            
            const response = await axios.post(this.apiUrl, requestBody, {
                headers: {
                    'Content-Type': 'application/json',
                    'X-Goog-Api-Key': this.apiKey
                },
                timeout: 15000 // 15 seconds timeout
            });
            
            if (response.data && response.data.candidates && response.data.candidates[0]) {
                const aiReply = response.data.candidates[0].content.parts[0].text.trim();
                
                // Clean up the response
                return this.cleanAIResponse(aiReply);
            }
            
            console.log('‚ö†Ô∏è No valid response from Gemini API');
            return null;
            
        } catch (error) {
            if (error.response) {
                console.error('‚ùå Gemini API error:', error.response.status, error.response.data);
            } else if (error.request) {
                console.error('‚ùå Gemini API network error:', error.message);
            } else {
                console.error('‚ùå Gemini API setup error:', error.message);
            }
            return null;
        }
    }
    
    cleanAIResponse(response) {
        // Remove markdown formatting
        let cleaned = response.replace(/\*\*(.*?)\*\*/g, '$1'); // Remove bold
        cleaned = cleaned.replace(/\*(.*?)\*/g, '$1'); // Remove italic
        cleaned = cleaned.replace(/`(.*?)`/g, '$1'); // Remove code formatting
        
        // Remove excessive line breaks
        cleaned = cleaned.replace(/\n\s*\n\s*\n/g, '\n\n');
        
        // Trim and ensure reasonable length
        cleaned = cleaned.trim();
        
        // Limit response length (WhatsApp friendly)
        if (cleaned.length > 500) {
            cleaned = cleaned.substring(0, 497) + '...';
        }
        
        return cleaned;
    }
    
    getConversationHistory(fromNumber) {
        return this.conversationHistory.get(fromNumber) || [];
    }
    
    updateConversationHistory(fromNumber, userMessage, aiReply, language) {
        const history = this.getConversationHistory(fromNumber);
        
        history.push({
            userMessage,
            aiReply,
            language,
            timestamp: new Date().toISOString()
        });
        
        // Keep only last 10 messages to prevent memory issues
        if (history.length > 10) {
            history.shift();
        }
        
        this.conversationHistory.set(fromNumber, history);
    }
    
    checkRateLimit(fromNumber) {
        const now = Date.now();
        const userLimits = this.rateLimits.get(fromNumber) || { count: 0, resetTime: now };
        
        // Reset counter every minute
        if (now > userLimits.resetTime) {
            userLimits.count = 0;
            userLimits.resetTime = now + 60000; // 1 minute
        }
        
        // Check if limit exceeded (max 2 messages per minute)
        if (userLimits.count >= parseInt(process.env.MESSAGE_RATE_LIMIT) || 2) {
            return false;
        }
        
        userLimits.count++;
        this.rateLimits.set(fromNumber, userLimits);
        
        return true;
    }
    
    getFallbackReply(language) {
        const fallbacks = {
            hinglish: 'Sorry yaar, thoda issue ho gaya. Tum bolo kya chahiye? üòÖ',
            hindi: '‡§Æ‡§æ‡§´ ‡§ï‡§∞‡•á‡§Ç, ‡§ï‡•Å‡§õ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•ã ‡§ó‡§à‡•§ ‡§Ü‡§™ ‡§¨‡§§‡§æ‡§è‡§Ç ‡§ï‡•ç‡§Ø‡§æ ‡§ö‡§æ‡§π‡§ø‡§è? üòÖ',
            english: 'Sorry, I encountered an issue. What can I help you with? üòÖ',
            urdu: 'ŸÖÿπÿßŸÅ ⁄©ÿ±€å⁄∫ÿå ⁄©⁄Ü⁄æ ŸÖÿ≥ÿ¶ŸÑ€Å €ÅŸà ⁄Ø€åÿß€î ÿ¢Ÿæ ÿ®ÿ™ÿßÿ¶€å⁄∫ ⁄©€åÿß ⁄Üÿß€Å€å€íÿü üòÖ',
            bengali: '‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶¨‡¶≤‡ßÅ‡¶® ‡¶ï‡ßÄ ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá? üòÖ',
            tamil: '‡ÆÆ‡Æ©‡Øç‡Æ©‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç, ‡Æö‡Æø‡Æ≤ ‡Æ™‡Æø‡Æ∞‡Æö‡Øç‡Æö‡Æ©‡Øà ‡Æè‡Æ±‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ. ‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æé‡Æ©‡Øç‡Æ© ‡Æµ‡Øá‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æé‡Æ©‡Øç‡Æ±‡ØÅ ‡Æö‡Øä‡Æ≤‡Øç‡Æ≤‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç? üòÖ',
            gujarati: '‡™Æ‡™æ‡™´ ‡™ï‡™∞‡™∂‡´ã, ‡™•‡´ã‡™°‡´Ä ‡™∏‡™Æ‡™∏‡´ç‡™Ø‡™æ ‡™•‡™à. ‡™§‡™Æ‡´á ‡™ï‡™π‡´ã ‡™∂‡´Å‡™Ç ‡™ú‡´ã‡™à‡™è? üòÖ'
        };
        
        return fallbacks[language] || fallbacks.hinglish;
    }
    
    cleanupOldConversations() {
        const now = Date.now();
        const maxAge = 24 * 60 * 60 * 1000; // 24 hours
        
        let cleanedCount = 0;
        
        for (const [fromNumber, history] of this.conversationHistory.entries()) {
            if (history.length === 0) {
                this.conversationHistory.delete(fromNumber);
                cleanedCount++;
                continue;
            }
            
            const lastMessage = history[history.length - 1];
            const messageAge = now - new Date(lastMessage.timestamp).getTime();
            
            if (messageAge > maxAge) {
                this.conversationHistory.delete(fromNumber);
                cleanedCount++;
            }
        }
        
        if (cleanedCount > 0) {
            console.log(`üßπ Cleaned up ${cleanedCount} old conversations`);
        }
        
        // Also cleanup rate limits
        for (const [fromNumber, limits] of this.rateLimits.entries()) {
            if (now > limits.resetTime + 300000) { // 5 minutes old
                this.rateLimits.delete(fromNumber);
            }
        }
    }
    
    // Get conversation stats
    getStats() {
        return {
            activeConversations: this.conversationHistory.size,
            totalMessages: Array.from(this.conversationHistory.values())
                .reduce((sum, history) => sum + history.length, 0),
            rateLimitedUsers: this.rateLimits.size,
            languages: this.getLanguageStats()
        };
    }
    
    getLanguageStats() {
        const languageCounts = {};
        
        for (const history of this.conversationHistory.values()) {
            for (const entry of history) {
                languageCounts[entry.language] = (languageCounts[entry.language] || 0) + 1;
            }
        }
        
        return languageCounts;
    }
    
    // Handle special commands
    handleSpecialCommands(message, fromNumber) {
        const lowerMessage = message.toLowerCase().trim();
        
        // Help command
        if (lowerMessage === '/help' || lowerMessage === 'help' || lowerMessage === '‡§Æ‡§¶‡§¶') {
            return this.getHelpMessage(this.detectLanguage(message));
        }
        
        // Clear history command
        if (lowerMessage === '/clear' || lowerMessage === 'clear history') {
            this.conversationHistory.delete(fromNumber);
            return 'Conversation history cleared! üßπ';
        }
        
        // Status command
        if (lowerMessage === '/status') {
            const stats = this.getStats();
            return `Bot Status:\n‚úÖ Active\nüí¨ ${stats.activeConversations} conversations\nüìä ${stats.totalMessages} total messages`;
        }
        
        return null; // No special command found
    }
    
    getHelpMessage(language) {
        const helpMessages = {
            hinglish: `ü§ñ ${this.botName} Help:\n\nüì± Main features:\n‚Ä¢ Natural conversation in multiple languages\n‚Ä¢ Smart replies with context\n‚Ä¢ Remembers our chat history\n\nüîß Commands:\n/help - Show this help\n/clear - Clear chat history\n/status - Bot status\n\nüí¨ Just chat normally, I'll understand! üòä`,
            
            hindi: `ü§ñ ${this.botName} ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ:\n\nüì± ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§µ‡§ø‡§∂‡•á‡§∑‡§§‡§æ‡§è‡§Ç:\n‚Ä¢ ‡§ï‡§à ‡§≠‡§æ‡§∑‡§æ‡§ì‡§Ç ‡§Æ‡•á‡§Ç ‡§™‡•ç‡§∞‡§æ‡§ï‡•É‡§§‡§ø‡§ï ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§\n‚Ä¢ ‡§∏‡§Ç‡§¶‡§∞‡•ç‡§≠ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§â‡§§‡•ç‡§§‡§∞\n‚Ä¢ ‡§ö‡•à‡§ü ‡§á‡§§‡§ø‡§π‡§æ‡§∏ ‡§Ø‡§æ‡§¶ ‡§∞‡§ñ‡§§‡§æ ‡§π‡•à\n\nüîß ‡§ï‡§Æ‡§æ‡§Ç‡§°:\n/help - ‡§Ø‡§π ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§¶‡§ø‡§ñ‡§æ‡§è‡§Ç\n/clear - ‡§ö‡•à‡§ü ‡§á‡§§‡§ø‡§π‡§æ‡§∏ ‡§∏‡§æ‡§´‡§º ‡§ï‡§∞‡•á‡§Ç\n/status - ‡§¨‡•â‡§ü ‡§∏‡•ç‡§•‡§ø‡§§‡§ø\n\nüí¨ ‡§¨‡§∏ ‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§ö‡•à‡§ü ‡§ï‡§∞‡•á‡§Ç, ‡§Æ‡•à‡§Ç ‡§∏‡§Æ‡§ù ‡§ú‡§æ‡§ä‡§Ç‡§ó‡§æ! üòä`,
            
            english: `ü§ñ ${this.botName} Help:\n\nüì± Main features:\n‚Ä¢ Natural conversation in multiple languages\n‚Ä¢ Smart contextual replies\n‚Ä¢ Remembers chat history\n\nüîß Commands:\n/help - Show this help\n/clear - Clear chat history\n/status - Bot status\n\nüí¨ Just chat normally, I understand multiple languages! üòä`
        };
        
        return helpMessages[language] || helpMessages.hinglish;
    }
    
    // Advanced language processing
    async processAdvancedLanguage(message, language) {
        // Handle code-switching (language mixing within same message)
        if (language === 'hinglish') {
            // Identify dominant language in mixed content
            const hindiWords = (message.match(/[\u0900-\u097F]+/g) || []).length;
            const englishWords = (message.match(/[a-zA-Z]+/g) || []).length;
            
            return {
                dominantLanguage: hindiWords > englishWords ? 'hindi' : 'english',
                mixedContent: true,
                hindiRatio: hindiWords / (hindiWords + englishWords)
            };
        }
        
        return {
            dominantLanguage: language,
            mixedContent: false,
            hindiRatio: 0
        };
    }
    
    // Sentiment analysis (basic)
    analyzeSentiment(message) {
        const positiveWords = ['good', 'great', 'awesome', 'nice', 'love', 'happy', '‡§Ö‡§ö‡•ç‡§õ‡§æ', '‡§¨‡§¢‡§º‡§ø‡§Ø‡§æ', '‡§ñ‡•Å‡§∂', '‡¶™‡ßç‡¶∞‡¶ø‡¶Ø‡¶º', '‡¶≠‡¶æ‡¶≤'];
        const negativeWords = ['bad', 'sad', 'angry', 'hate', 'problem', 'issue', '‡§¨‡•Å‡§∞‡§æ', '‡§¶‡•Å‡§ñ‡•Ä', '‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ', '‡¶ñ‡¶æ‡¶∞‡¶æ‡¶™', '‡¶¶‡ßÅ‡¶É‡¶ñ'];
        
        const lowerMessage = message.toLowerCase();
        let positiveCount = positiveWords.filter(word => lowerMessage.includes(word)).length;
        let negativeCount = negativeWords.filter(word => lowerMessage.includes(word)).length;
        
        if (positiveCount > negativeCount) return 'positive';
        if (negativeCount > positiveCount) return 'negative';
        return 'neutral';
    }
    
    // Context-aware reply generation
    async generateContextAwareReply(message, fromNumber, context = {}) {
        // Check for special commands first
        const specialCommand = this.handleSpecialCommands(message, fromNumber);
        if (specialCommand) {
            return specialCommand;
        }
        
        // Analyze sentiment
        const sentiment = this.analyzeSentiment(message);
        context.sentiment = sentiment;
        
        // Process language
        const language = this.detectLanguage(message);
        const advancedLang = await this.processAdvancedLanguage(message, language);
        context.languageAnalysis = advancedLang;
        
        return await this.generateReply(message, fromNumber, context);
    }
    
    // Health check
    healthCheck() {
        return {
            status: 'healthy',
            apiKey: !!this.apiKey,
            model: this.model,
            activeConversations: this.conversationHistory.size,
            rateLimitedUsers: this.rateLimits.size,
            lastCleanup: this.lastCleanup || null
        };
    }
    
    // Graceful shutdown
    shutdown() {
        console.log('ü§ñ AI Reply system shutting down...');
        this.conversationHistory.clear();
        this.rateLimits.clear();
        console.log('‚úÖ AI Reply system shutdown complete');
    }
}

module.exports = AIReply;
